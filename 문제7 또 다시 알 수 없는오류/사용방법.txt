포함 파일

database.py : contextlib.contextmanager로 get_db() 구현, FastAPI Depends용 래퍼 get_db_dep() 제공

models.py : Question ORM 모델

schemas.py : QuestionRead Pydantic 스키마(기본 orm_mode=True)

domain/question/question_router.py : GET /api/question 목록 라우트(ORM → 스키마 직렬화)

main.py : 라우터 등록 및 초기 테이블 생성

README.md : 실행/확인 가이드

핵심 변경 사항

자동 연결 종료

database.py

@contextmanager def get_db()에서 세션 생성 → yield → finally: close()로 자동 종료.

FastAPI가 컨텍스트 매니저 객체를 직접 Depends로 소화하지 못하므로, get_db_dep() 래퍼에서 with get_db() as db:로 진입 후 yield db 합니다. 이렇게 해야 매 요청마다 생성·종료가 보장됩니다.

스키마 적용

schemas.py의 QuestionRead를 response_model로 사용하여 응답을 명확히 정의했습니다.

orm_mode=True 상태에서는 SQLAlchemy ORM 인스턴스를 그대로 반환해도 스키마가 속성을 읽어 직렬화합니다.

실행 방법

pip install fastapi uvicorn sqlalchemy alembic pydantic
uvicorn main:app --reload
# 문서: http://127.0.0.1:8000/docs
# 목록: GET /api/question


검증 포인트

라우트를 여러 번 호출해도 세션 핸들이 누수되지 않는지(로그/모니터링으로 파일 디스크립터, 연결 수 확인).

schemas.py의 Config.orm_mode를 False로 바꾼 뒤 서버 재실행.

이 상태에서 ORM 인스턴스를 그대로 반환하면 Pydantic이 dict로 취급하지 못해 검증 오류가 납니다.

이유: orm_mode=True(Pydantic v1) 또는 from_attributes=True(v2) 설정이 있어야 속성 기반 접근으로 직렬화가 가능하기 때문입니다.

만약 orm_mode=False를 유지하고 싶다면, 라우트에서 [{...}, {...}] 형태의 순수 dict로 변환하여 반환해야 합니다.

이 구성이면 요청마다 세션이 열리고 닫히는 흐름이 일정해져 “열고 안 닫는” 류의 장애를 예방할 수 있습니다
